<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCC: SASS Documentation</title>
    <link rel="stylesheet" type="text/css" href="src/css/styles.css">
    <link rel="icon" type="icon" href="src/assets/icon/icon.png">
</head>
<body>
    
    <aside>
        <nav id="navbar">
            <header>
                <h1><span class="SASS-color">SASS</span> Documentation</h1>
            </header>
            <div class="container-links">
                <a href="#¿What_is_Sass?" class="nav-link">¿What is Sass?</a>
                <a href="#Style_Rules" class="nav-link">Style Rules</a>
                <a href="#Nesting" class="nav-link">Nesting</a>
                <a href="#Variables" class="nav-link">Variables</a>
                <a href="#Mixins" class="nav-link">Mixins</a>
                <a href="#Extend" class="nav-link">Extend</a>
                <a href="#Use" class="nav-link">Use</a>
                <a href="#Forward" class="nav-link">Forward</a> 
                <a href="#Import" class="nav-link">Import</a>
                <a href="#Operators" class="nav-link">Operators</a>  
                <a href="#Reference" class="nav-link">Reference</a> 
            </div>
        </nav>
    </aside>

    <main id="main-doc">
        <section class="main-section" id="¿What_is_Sass?">
            <header>¿What is Sass?</header>
            <p>Sass is a stylesheet language that’s compiled to CSS. It allows you to use variables, nested rules, mixins, functions, and more, all with a fully CSS-compatible syntax. Sass helps keep large stylesheets well-organized and makes it easy to share design within and across projects.</p>
        </section>

        <section class="main-section" id="Style_Rules">
            <header>Style Rules</header>
            <article>
                <p>Style rules are the foundation of Sass, just like they are for CSS. And they work the same way: you choose which elements to style with a selector, and declare properties that affect how those elements look</p>
            <code class="text-code"> 
                <ul class="container-property">
                    <li class="css-class">.button {
                        <ul class="container-property">
                            <li class="css-property"><span class="name-property">padding:</span> 3px 10px;</li>
                            <li class="css-property"><span class="name-property">font-size:</span> 12px;</li>
                            <li class="css-property"><span class="name-property">border-radius:</span> 3px;</li>
                            <li class="css-property"><span class="name-property">border:</span> 3px solid #e1e4e8;</li>
                        </ul>
                    }</li>
                </ul>
            </code>
            </article>
        </section>

        <section class="main-section" id="Nesting">
            <header>Nesting</header>
            <article>
                <p>But Sass wants to make your life easier. Rather than repeating the same selectors over and over again, you can write one style rules inside another. Sass will automatically combine the outer rule’s selector with the inner rule’s.</p>
            <code class="text-code">
                <ul class="container-property">
                    <li class="css-class">nav {

                        <ul class="container-property"> 
                            <li class="css-class">ul {
                                <ul>
                                <li class="css-property"><span class="name-property">margin:</span> 0;</li>
                                <li class="css-property"><span class="name-property">padding:</span> 0;</li>
                                <li class="css-property"><span class="name-property">list-style:</span> none;</li>
                                </ul>
                            }</li>
                        </ul>

                        <ul class="container-property">
                            <li class="css-class">li {
                                <ul>
                                    <li class="css-property"><span class="name-property">display:</span> inline-block;</li>
                                </ul> 
                            }</li>
                        </ul>

                        <ul class="container-property">
                            <li class="css-clas">a {
                                <ul>
                                    <li class="css-property"><span class="name-property">display:</span> block;</li>
                                    <li class="css-property"><span class="name-property">padding:</span> 6px 12px;</li>
                                    <li class="css-property"><span class="name-property">text-decoration:</span> none;</li>
                                </ul>    
                            }</li>
                        </ul>

                    }</li>
                </ul>
            </code>
            </article>
        </section>

        <section class="main-section" id="Variables">
            <header>Variables</header>
            <article>
                <p>A variable declaration looks a lot like a property declaration: it’s written <variable>: <expression>. Unlike a property, which can only be declared in a style rule or at-rule, variables can be declared anywhere you want. To use a variable, just include it in a value.</p>
                    <code class="text-code">
                        <ul class="container-property">
                            <li class="css-class">$base-color: #c6538c;</li>
                            <li class="css-class">$border-dark: rgba($base-color, 0.88);</li>
                        </ul>
        
                        <ul class="container-property">
                            <li class="css-class">.alert {
                                <ul>
                                    <li class="css-property"><span class="name-property">border:</span> 1px solid $border-dark;</li>
                                </ul>
                            }</li>
                        </ul>
                    </code>
            </article>
        </section>

        <section class="main-section" id="Mixins">
            <header>Mixins</header>
            <article>
                <p>Mixins allow you to define styles that can be re-used throughout your stylesheet. They make it easy to avoid using non-semantic classes like .float-left, and to distribute collections of styles in libraries.<br>
                    Mixins are defined using the <span class="highlited-text">@mixin at-rule</span>, which is written <span class="highlited-text">@mixin <name> { ... }</span> or <span class="highlited-text">@mixin name(<arguments...>) { ... }</span>. A mixin’s name can be any Sass identifier, and it can contain any statement other than top-level statements. They can be used to encapsulate styles that can be dropped into a single style rule; they can contain style rules of their own that can be nested in other rules or included at the top level of the stylesheet; or they can just serve to modify variables.
                    Mixins are included into the current context using the <span class="highlited-text">@include</span> at-rule, which is written <span class="highlited-text">@include <name></span> or <span class="highlited-text">@include <name>(<arguments...>)</span>, with the name of the mixin being included.</p>
                
                    <code class="text-code">
                        <ul class="container-property">
                            <li class="css-class">@mixin reset-list {
                                <ul>
                                    <li class="css-property"><span class="name-property">margin:</span> 0;</li>
                                    <li class="css-property"><span class="name-property">padding:</span> 0;</li>
                                    <li class="css-property"><span class="name-property">list-style:</span> none;</li>
                                </ul>
                            }</li>
                        </ul>
        
                        <ul class="container-property">
                            <li class="css-class"><span class="highlited-text">@mixin</span> horizontal-list{
                                <ul>
                                    <li class="css-class"><span class="highlited-text">@include</span> reset-list;</li>
                                    <li class="css-class">li {
                                            <ul>
                                                <li class="css-property"><span class="name-property">display:</span> inline-block;</li>
                                                <li class="css-property"><span class="name-property">margin:</span> 2rem;</li>
                                            </ul>
                                    }</li>
                                </ul>
                            }</li>
                        </ul>
        
                        <ul class="container-property">
                            <li class="css-class">nav ul{
                                <ul>
                                    <li><span class="highlited-text">@include</span> horizontal-list;</li>
                                </ul>
                            }</li>
                        </ul>
                    </code>
            </article>
        </section>

        <section class="main-section" id="Extend">
            <header>Extend</header>
            <article>
                <p>There are often cases when designing a page when one class should have all the styles of another class, as well as its own specific styles. For example, the BEM methodology encourages modifier classes that go on the same elements as block or element classes. But this can create cluttered HTML, it's prone to errors from forgetting to include both classes, and it can bring non-semantic style concerns into your markup. Sass’s <span class="highlited-text">@extend</span> rule solves this. It’s written <span class="highlited-text">@extend < selector > </span>, and it tells Sass that one selector should inherit the styles of another.</p>
                <code class="text-code">
                    <ul class="container-property">
                        <li class="css-class">.error {
                            <ul>
                                <li class="css-property"><span class="name-property">border:</span> 1px #f98;</li>
                                <li class="css-property"><span class="name-property">background-color:</span> #fdd;</li>
                            </ul>

                            <ul class="container-property">
                                <li class="css-class">&--serious {
                                    <li class="css-class"><span class="highlited-text">@extend</span> .error;</li>
                                    <li class="css-property"><span class="name-property">border-with:</span> 3px;</li>
                                }</li>
                            </ul>
                        }</li>
                    </ul>
                </code>
                <p>When one class extends another, Sass styles all elements that match the extender as though they also match the class being extended. When one class selector extends another, it works exactly as though you added the extended class to every element in your HTML that already had the extending class. You can just write class="error--serious", and Sass will make sure it’s styled as though it had class="error" as well.</p>
                <p>Of course, selectors aren’t just used on their own in style rules. Sass knows to extend everywhere the selector is used. This ensures that your elements are styled exactly as if they matched the extended selector.</p>
                <code class="text-code">
                    <ul class="container-property">
                        <li class="css-class">.error:hover {
                            <ul>
                                <li class="css-property"><span class="name-property">background-color:</span> #f3e;</li>
                            </ul>
                        }</li>
                    </ul>

                    <ul class="container-property">
                        <li class="css-class">-error--serious{
                            <li class="css-class"><span class="highlited-text">@extend</span> .error;</li>
                            <li class="css-property"><span class="name-property">border-width:</span> 3px;</li>
                        }</li>
                    </ul>
                </code>
                <h2>Heads up!</h3>
                <p>Extends are resolved after the rest of your stylesheet is compiled. In particular, it happens after <span class="highlited-text">parent selectors</span> are resolved. This means that if you <span class="highlited-text">@extend .error</span>, it won’t affect the inner selector in <span class="highlited-text">.error { &__icon { ... } }</span>. It also means that parent selectors in SassScript can’t see the results of extend.</p>
            </article>    
        </section>
        
        <section class="main-section" id="Use">
            <header>Use</header>
            <p>The <span highlited-text>@use</span> rule loads mixins, functions, and variables from other Sass stylesheets, and combines CSS from multiple stylesheets together. Stylesheets loaded by <span class="highlited-text">@use</span> are called "modules". Sass also provides built-in modules full of useful functions.</p>
            <p>The simplest <span class="highlited-text">@use</span> rule is written <span class="highlited-text">@use "<url>"</span>, which loads the module at the given URL. Any styles loaded this way will be included exactly once in the compiled CSS output, no matter how many times those styles are loaded.</p>
        </section>

        <section class="main-section" id="Forward">
            <header>Forward</header>
            <p>The <span class="highlited-text">@forward</span> rule loads a Sass stylesheet and makes its mixins, functions, and variables available when your stylesheet is loaded with the <span class="highlited-text">@use</span> rule. It makes it possible to organize Sass libraries across many files, while allowing their users to load a single entrypoint file.</p>
            <p>The rule is written <span class="highlited-text">@forward "<url>"</span>. It loads the module at the given URL just like <span class="highlited-text">@use</span>, but it makes the public members of the loaded module available to users of your module as though they were defined directly in your module. Those members aren’t available in your module, though—if you want that, you’ll need to write a @use rule as well. Don’t worry, it’ll only load the module once!</p>
        </section>

        <section class="main-section" id="Import">
            <header>Import</header>
            <article>
                <p>Sass extends CSS's @import rule with the ability to import Sass and CSS stylesheets, providing access to mixins, functions, and variables and combining multiple stylesheets' CSS together. Unlike plain CSS imports, which require the browser to make multiple HTTP requests as it renders your page, Sass imports are handled entirely during compilation.</p>
                <p>Sass imports have the same syntax as CSS imports, except that they allow multiple imports to be separated by commas rather than requiring each one to have its own <span class="highlited-text">@import</span>. Also, in the indented syntax, imported URLs aren’t required to have quotes.</p>
                <h2>Heads Up!</h2>
                <p>The Sass team discourages the continued use of the @import rule. Sass will gradually phase it out over the next few years, and eventually remove it from the language entirely. Prefer the <span class="highlited-text">@use</span> rule instead. (Note that only Dart Sass currently supports @use. Users of other implementations must use the @import rule instead.)</p>
            </article>
        </section>

        <section class="main-section" id="Operators">
            <header>Operators</header>
            <p>Sass supports a handful of useful <span class="highlited-text">operators</span> for working with different values. These include the standard mathematical operators like <span class="highlited-text">+</span> and <span class="highlited-text">*</span>, as well as operators for various other types:</p>
            <ul>
                <li>== >and != are used to check if two values are the same.</li>
                <li>+, -, *, /, and % have their usual mathematical meaning for numbers, with special behaviors for units that matches the use of units in scientific math.</li>
                <li><, <=, >, and >= check whether two numbers are greater or less than one another</li>
                <li>and, or, and not have the usual boolean behavior. Sass considers every value “true” except for false and null.</li>
                <li>+, -, and / can be used to concatenate strings.</li>
            </ul>
        </section>

        <section class="main-section" id="Reference">
            <header>Reference</header>
            <ul>
                <li>All the documentation in this page is taken from <a href="https://sass-lang.com/documentation">SASS Documentation</a></li>
            </ul>
        </section>
    </main>
</body>
<script src='https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js'></script>
</html>